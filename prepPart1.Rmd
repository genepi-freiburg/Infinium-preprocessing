## PART 1: Read data and parameters

```{r, message = FALSE}
#####################

 #read data
 cwd<-getwd()

 setwd(idatdir)
 # cwd
 # getwd()
 filenames <- unique(gsub("_Grn.idat","",gsub("_Red.idat","",dir(pattern="\\.idat$"),ignore.case=T),ignore.case=T))

dim(filenames) <- c(length(filenames)/2,2)

detectionP.local <- function (rgSet, type = "m+u")
{
    locusNames <- getManifestInfo(rgSet, "locusNames")
    detP <- matrix(NA_real_, ncol = ncol(rgSet), nrow = length(locusNames),
        dimnames = list(locusNames, sampleNames(rgSet))) 
    controlIdx <- getControlAddress(rgSet, controlType = "NEGATIVE")
    r <- getRed(rgSet)
    rBg <- r[controlIdx, ]
    rMu <- colMedians(rBg)
    rSd <- colMads(rBg)
    g <- getGreen(rgSet) 
    gBg <- g[controlIdx, ]
    gMu <- colMedians(gBg)
    gSd <- colMads(gBg)
    TypeII <- getProbeInfo(rgSet, type = "II")
    TypeI.Red <- getProbeInfo(rgSet, type = "I-Red")
    TypeI.Green <- getProbeInfo(rgSet, type = "I-Green")

    minSd <- 0.000001
    for (i in 1:ncol(rgSet)) {
        # change sd to min 0.000001
        intensity <- r[TypeI.Red$AddressA, i] + r[TypeI.Red$AddressB, i]
        detP[TypeI.Red$Name, i] <- 1 - pnorm(intensity, mean = rMu[i] * 2, sd = max(rSd[i],minSd) * 2)
        intensity <- g[TypeI.Green$AddressA, i] + g[TypeI.Green$AddressB, i] 
        detP[TypeI.Green$Name, i] <- 1 - pnorm(intensity, mean = gMu[i] * 2, sd = max(gSd[i],minSd) * 2)
        intensity <- r[TypeII$AddressA, i] + g[TypeII$AddressA, i]
        detP[TypeII$Name, i] <- 1 - pnorm(intensity, mean = rMu[i] + gMu[i], sd = max(rSd[i] + gSd[i],minSd))
    }
    detP
}

for(i in 1:nrow(filenames)) {
	### 1 line here different
	RGset <- read.metharray(filenames[i,], verbose=TRUE) # formerly: read.450k()
	RGset <- bgcorrect.illumina(RGset)  # Illumina background subtraction 
	# Type II probes
	TypeII.Name <- getProbeInfo(RGset, type = "II")$Name
	TypeII.Green <- getGreen(RGset)[getProbeInfo(RGset, type = "II")$AddressA,]
	TypeII.Red <- getRed(RGset)[getProbeInfo(RGset, type = "II")$AddressA,]
	rownames(TypeII.Red) <- TypeII.Name
	colnames(TypeII.Red) <- sampleNames(RGset)
	rownames(TypeII.Green) <- TypeII.Name
	colnames(TypeII.Green) <- sampleNames(RGset)

	# Type I probes, split into green and red channels
	TypeI.Green.Name <- getProbeInfo(RGset, type = "I-Green")$Name
	TypeI.Green.M <- getGreen(RGset)[getProbeInfo(RGset, type = "I-Green")$AddressB,]
	rownames(TypeI.Green.M) <- TypeI.Green.Name
	colnames(TypeI.Green.M) <- sampleNames(RGset)
	TypeI.Green.U <- getGreen(RGset)[getProbeInfo(RGset, type = "I-Green")$AddressA,]
	rownames(TypeI.Green.U) <- TypeI.Green.Name
	colnames(TypeI.Green.U) <- sampleNames(RGset)

	TypeI.Red.Name <- getProbeInfo(RGset, type = "I-Red")$Name
	TypeI.Red.M <- getRed(RGset)[getProbeInfo(RGset, type = "I-Red")$AddressB,]
	rownames(TypeI.Red.M) <- TypeI.Red.Name
	colnames(TypeI.Red.M) <- sampleNames(RGset)
	TypeI.Red.U <- getRed(RGset)[getProbeInfo(RGset, type = "I-Red")$AddressA,]
	rownames(TypeI.Red.U) <- TypeI.Red.Name
	colnames(TypeI.Red.U) <- sampleNames(RGset)

	### until next ### different: control defined 
	control=getProbeInfo(RGset, type = "Control") # needed also for lowlevel QC

	#BSC1 control probes - 450k: 16:18 ### 1:18 sind fÃ¼r 45ok die Zeilen control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Green","LimeGreen","Lime")) 
        BSCI.Green.Name = control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Green","LimeGreen","Lime")),]$ExtendedType
        BSCI.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(BSCI.Green.Name), dimnames = list(BSCI.Green.Name, sampleNames(RGset)))
        BSCI.Green[BSCI.Green.Name,] <- getGreen(RGset)[control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Green","LimeGreen","Lime")),]$Address,]
        # 450k: 22:24 ### 22:24 entsprechen control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Purple","Red","Tomato"))
        BSCI.Red.Name = control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Purple","Red","Tomato")),]$ExtendedType
        BSCI.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(BSCI.Red.Name), dimnames = list(BSCI.Red.Name, sampleNames(RGset)))
        BSCI.Red[BSCI.Red.Name,] <- getRed(RGset)[control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Purple","Red","Tomato")),]$Address,]

        #BSC2 control probes - 450k: 28:31 ### s.o. 
        BSCII.Red.Name = control[control$Type=="BISULFITE CONVERSION II",]$ExtendedType
        BSCII.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(BSCII.Red.Name), dimnames = list(BSCII.Red.Name, sampleNames(RGset)))
        BSCII.Red[BSCII.Red.Name,] <- getRed(RGset)[control[control$Type=="BISULFITE CONVERSION II",]$Address,]
	
	# select control probes green channel by ExtendedType:
        # STAINING, EXTENSION, HYBRIDISATION, TARGET REMOVAL, Specificity I+II, NON POLYMORPHIC
        extendedTypeGreen=c("Biotin (High)","Extension (C)","Extension (G)","Hyb (High)","Hyb (Medium)","Hyb (Low)","Target Removal 1","Target Removal 2","GT Mismatch 1 (PM)","GT Mismatch 2 (PM)","GT Mismatch 3 (PM)","NP (C)","NP (G)")
        extendedTypeRed=c("DNP (High)","Extension (A)","Extension (T)","GT Mismatch 4 (PM)","GT Mismatch 5 (PM)","GT Mismatch 6 (PM)","Specificity 1","Specificity 2","Specificity 3","NP (A)","NP (T)")

        controlExtGreen <- control[control$ExtendedType %in% extendedTypeGreen,]
        controlExtRed <- control[control$ExtendedType %in% extendedTypeRed,]

        ctlext.Red.Name = controlExtRed$ExtendedType
        ctlext.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(ctlext.Red.Name), dimnames = list(ctlext.Red.Name, sampleNames(RGset)))
        ctlext.Red[ctlext.Red.Name,] <- getRed(RGset)[controlExtRed$Address,]
        ctlext.Green.Name = controlExtGreen$ExtendedType
        ctlext.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(ctlext.Green.Name), dimnames = list(ctlext.Green.Name, sampleNames(RGset)))
        ctlext.Green[ctlext.Green.Name,] <- getGreen(RGset)[controlExtGreen$Address,]

	### the upper selection of information of extended type is in a more condensed form by AT ; normalization has to be added by hand 

	#Normalisation
	normC.Green.Name=control[control[,2]=='NORM_C',4]
	normC.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normC.Green.Name), dimnames = list(normC.Green.Name, sampleNames(RGset)))
	normC.Green[normC.Green.Name,] <- getGreen(RGset)[control[control[,2]=='NORM_C',1],]
	normG.Green.Name=control[control[,2]=='NORM_G',4]
	normG.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normG.Green.Name), dimnames = list(normG.Green.Name, sampleNames(RGset)))
	normG.Green[normG.Green.Name,] <- getGreen(RGset)[control[control[,2]=='NORM_G',1],]
	normA.Red.Name=control[control[,2]=='NORM_A',4]
	normA.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normA.Red.Name), dimnames = list(normA.Red.Name, sampleNames(RGset)))
	normA.Red[normA.Red.Name,] <- getRed(RGset)[control[control[,2]=='NORM_A',1],]
	normT.Red.Name=control[control[,2]=='NORM_T',4]
	normT.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normT.Red.Name), dimnames = list(normT.Red.Name, sampleNames(RGset)))
	normT.Red[normT.Red.Name,] <- getRed(RGset)[control[control[,2]=='NORM_T',1],]
	
	### here is code added for lowlevel QC (until combine ctrl probe intensities)
	
	# added for lowlevel QC
        #build dataframe with all control probes
        bufR <- intersect(rownames(getRed(RGset)),control[,1])
        bufG <- intersect(rownames(getGreen(RGset)),control[,1])
        control_ok.Red <- control[control[,1] %in% bufR,] # some controls seem to be in annotation file but not on array
        control_ok.Green <- control[control[,1] %in% bufG,] # some controls seem to be in annotation file but not on array

        # added for lowlevel QC
        # controls probes for red and green channel
        ctrl.complete.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = nrow(control_ok.Red), dimnames = list(control_ok.Red[,4], sampleNames(RGset)))
        ctrl.complete.Red <- getRed(RGset)[control_ok.Red[,1],]
        ctrl.complete.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = nrow(control_ok.Green), dimnames = list(control_ok.Green[,4], sampleNames(RGset)))
        ctrl.complete.Green <- getGreen(RGset)[control_ok.Green[,1],]
	
	#combine ctrl probe intensities ### shorter 
        ctrl = rbind(as.matrix(BSCI.Green), as.matrix(BSCI.Red), as.matrix(BSCII.Red), (ctlext.Red), (ctlext.Green),as.matrix(normC.Green),as.matrix(normG.Green), as.matrix(normA.Red),as.matrix(normT.Red))

	#detection p-values
	dp = detectionP.local(RGset, type = "m+u") ### formerly: detectionP(RGset, type = "m+u")

	
	#add data for the new samples
	if(exists("TypeII.Red.All")) {
	TypeII.Red.All <- cbind(TypeII.Red.All,TypeII.Red)
	TypeII.Green.All <- cbind(TypeII.Green.All,TypeII.Green)
	TypeI.Red.M.All <- cbind(TypeI.Red.M.All,TypeI.Red.M)
	TypeI.Red.U.All <- cbind(TypeI.Red.U.All,TypeI.Red.U)
	TypeI.Green.M.All <- cbind(TypeI.Green.M.All,TypeI.Green.M)
	TypeI.Green.U.All <- cbind(TypeI.Green.U.All,TypeI.Green.U)
	ctrl.all <- rbind(ctrl.all, t(ctrl))
	## added for lowlevel QC by AT 
	ctrl.complete.Red.all <- cbind(ctrl.complete.Red.all, ctrl.complete.Red) # added for lowlevel QC
        ctrl.complete.Green.all <- cbind(ctrl.complete.Green.all, ctrl.complete.Green) # added for lowlevel QC
	dp.all <- cbind(dp.all, dp)
	}
	else {
	TypeII.Red.All <- TypeII.Red                                                                                                                                  
	TypeII.Green.All <- TypeII.Green 
	TypeI.Red.M.All <- TypeI.Red.M 
	TypeI.Red.U.All <- TypeI.Red.U 
	TypeI.Green.M.All <- TypeI.Green.M 
	TypeI.Green.U.All <- TypeI.Green.U     
	ctrl.all <- t(ctrl)
	ctrl.complete.Red.all <- ctrl.complete.Red # added for lowlevel QC
        ctrl.complete.Green.all <- ctrl.complete.Green # added for lowlevel QC
        dp.all <- dp
	}
	
	# added 18.04.18 by FGC: minfi WBC estimation based on RGsets only 
	
	est_wbc <- estimateCellCounts(RGset, compositeCellType = "Blood", cellTypes = c("CD8T","CD4T", "NK","Bcell","Mono","Gran"))
	if(exists("est.minfi")){
		est.minfi = rbind(est_wbc, est_wbc)
	} else {
		est.minfi = as.data.frame(est_wbc)
	}
	
}
setwd(cwd)

```

We are working with data from directory `r idatdir` which contains $`r length(filenames) `$ idat files.
The annotationfile used is 

`r annotationfile` 
- if problems occur with annotation, please have a look at [Illumina downloads](https://support.illumina.com/array/downloads.html)    *Infimum Methylation EPIC Product files*. 


Output is directed to `r outputdir`. We use samples listed in `r samplesfile` for quality control. 

As given in *parameterfile.R*, the following parameters were used: 

parameter                     | value
------------------------------|-------------------------------------
arraytype                     | `r arraytype`
detPthreshold                 | $`r detPthreshold`$
callrate.thres                | $`r callrate.thres`$
filterOutlierCtrlQC           | `r filterOutlierCtrlQC`
QuantileNormalize             | `r QuantileNormalize`
InterQuartileRangeCalculation | `r InterQuartileRangeCalculation`

Further we interpret the values for the gender in the samplesfile as **1=female** and **0=male**. 

```{r}
if(QuantileNormalize == TRUE && length(samplesfilefinal)==0){
	cat("In order to run Part 3: Quantile normalization and IQ-filter a final samplefile is needed.\n The samplesfile of the first and second part will be used instead.")
	samplesfilefinal <- samplesfile
}
if(QuantileNormalize == TRUE){cat(paste("The samples listed in", samplesfilefinal,"are used for quantile normalization \n and calculation of outliers regarding inter-quartile-range."))}
```


* PCA is conducted to get controlprobe scores. 

```{r}
#PCA of control-probe intensities
pca <- prcomp(na.omit(ctrl.all))
ctrlprobes.scores = pca$x
colnames(ctrlprobes.scores) = paste(colnames(ctrlprobes.scores), '_cp', sep='')

# ### extended savings 
 control.info <- data.frame(control)

### EOF for 1_intensities
```

* Detection p-values are calculated and illustrated in the following plots. Low p-values indicate that the signal is unlikely to be background noise. 

```{r}
# test
dpvec <- dp.all
dim(dpvec) <- c(nrow(dp.all)*ncol(dp.all),1)

# plot detection P
dpvecplot <- dpvec
dpvecplot[which(dpvecplot==0)] <- 1E-20
hist(-log10(dpvec),breaks=30, main = "detection p-values")
```





```{r}
hist(-log10(dpvecplot),breaks=30, main = "detection p-values: zero values set to 1E-20")
rm(dpvecplot)
```
\pagebreak


The following table summarizes how many detection p-values are smaller than the threshold $`r detPthreshold `$ given in the *parameterfile*, or 0.01: 

 threshold           | count                                       | percentage
---------------------|---------------------------------------------|-----------------------------------------------------
$`r detPthreshold `$ | $`r length(which(dpvec<detPthreshold))`$    | $`r length(which(dpvec<detPthreshold))/length(dpvec)`$
0.01                 | $`r length(which(dpvec<0.01))`$             | $`r length(which(dpvec<0.01))/length(dpvec)`$


```{r}
anno=read.csv(annotationfile,as.is=TRUE, skip = 7) 
 anno=anno[,c('Infinium_Design_Type','Color_Channel', 'CHR', 'MAPINFO', 'Name')]
# get autosomal probes
 cas=anno[substr(anno$Name, 1,3)=='ch.' & !(anno$CHR %in% c('X','Y')),]
 cgs=anno[substr(anno$Name, 1,2)=='cg'& !(anno$CHR %in% c('X','Y')),]
 auto = c(cgs$Name, cas$Name)
 auto=as.matrix(auto)

# get chrX probes
 xcas=anno[substr(anno$Name, 1,3)=='ch.' & (anno$CHR %in% c('X')),]
 xcgs=anno[substr(anno$Name, 1,2)=='cg'& (anno$CHR %in% c('X')),]
 sexchrX = c(xcgs$Name, xcas$Name)
 sexchrX=as.matrix(sexchrX)

 # get chrY probes
 ycas=anno[substr(anno$Name, 1,3)=='ch.' & (anno$CHR %in% c('Y')),]
 ycgs=anno[substr(anno$Name, 1,2)=='cg'& (anno$CHR %in% c('Y')),]
 sexchrY = c(ycgs$Name, ycas$Name)
 sexchrY=as.matrix(sexchrY)
```
  

```{r}
#set detection p-value threshold
thres=detPthreshold
d=dp.all[rownames(TypeII.Green.All),colnames(TypeII.Green.All)]
TypeII.Green.All.d = ifelse(d<thres,TypeII.Green.All,NA)
TypeII.Red.All.d = ifelse(d<thres,TypeII.Red.All,NA)
d=dp.all[rownames(TypeI.Green.M.All),colnames(TypeI.Green.M.All)]
TypeI.Green.M.All.d = ifelse(d<thres,TypeI.Green.M.All,NA)
TypeI.Green.U.All.d = ifelse(d<thres,TypeI.Green.U.All,NA)
d=dp.all[rownames(TypeI.Red.M.All),colnames(TypeI.Red.M.All)]
TypeI.Red.M.All.d = ifelse(d<thres,TypeI.Red.M.All,NA)
TypeI.Red.U.All.d = ifelse(d<thres,TypeI.Red.U.All,NA)
#rm(dp.all,d)

samples=colnames(TypeI.Red.M.All)
```

* The probes are divided by chromosome type: autosomal probes, chromosome X probes and chromosome Y probes.
$`r length(which(dpvec>detPthreshold))`$   ($`r round(length(which(dpvec>detPthreshold))/length(dpvec), digits = 3)`$ \%)   measurements are excluded because their detection p-value is bigger than $`r detPthreshold`$. Only values with a detection p-value strictly smaller the threshold are kept.
To skip this filtering, set the parameter *detPthreshold* to a value **strictly** bigger than 1 in the *parameterfile.R*.

* The data is divided into automomal chromosomes and gametes to calculate call rates and separate sets of beta values.

```{r}

#autosomes ------------------------------------------------------------------
 category=auto
 markers=as.matrix(intersect(rownames(TypeII.Green.All.d), category))
# head(markers)
TypeII.Green = TypeII.Green.All.d[markers,samples]
TypeII.Red = TypeII.Red.All.d[markers,samples]
markers=intersect(rownames(TypeI.Green.M.All.d), category)
TypeI.Green.M = TypeI.Green.M.All.d[markers,samples]
TypeI.Green.U = TypeI.Green.U.All.d[markers,samples]
markers=intersect(rownames(TypeI.Red.M.All.d), category)
TypeI.Red.M = TypeI.Red.M.All.d[markers,samples]
TypeI.Red.U = TypeI.Red.U.All.d[markers,samples]

#raw betas and callrate
TypeII.betas = TypeII.Green/(TypeII.Red+TypeII.Green+100)
TypeI.Green.betas = TypeI.Green.M/(TypeI.Green.M+TypeI.Green.U+100)
TypeI.Red.betas = TypeI.Red.M/(TypeI.Red.M+TypeI.Red.U+100)
beta.raw = as.matrix(rbind(TypeII.betas,TypeI.Green.betas,TypeI.Red.betas))
sample.call=colSums(!is.na(beta.raw.raw))/nrow(beta.raw)
marker.call=rowSums(!is.na(beta.raw))/ncol(beta.raw)

# sex chromosomes ------------------------------------------------------------------

category=c(sexchrX,sexchrY)
markers=as.matrix(intersect(rownames(TypeII.Green.All.d), category))
TypeII.Green = TypeII.Green.All.d[markers,samples]
TypeII.Red = TypeII.Red.All.d[markers,samples]
markers=intersect(rownames(TypeI.Green.M.All.d), category)
TypeI.Green.M = TypeI.Green.M.All.d[markers,samples]
TypeI.Green.U = TypeI.Green.U.All.d[markers,samples]
markers=intersect(rownames(TypeI.Red.M.All.d), category)
TypeI.Red.M = TypeI.Red.M.All.d[markers,samples]
TypeI.Red.U = TypeI.Red.U.All.d[markers,samples]

#raw betas
TypeII.betas = TypeII.Green/(TypeII.Red+TypeII.Green+100)
TypeI.Green.betas = TypeI.Green.M/(TypeI.Green.M+TypeI.Green.U+100)
TypeI.Red.betas = TypeI.Red.M/(TypeI.Red.M+TypeI.Red.U+100)
beta.raw.sex = as.matrix(rbind(TypeII.betas,TypeI.Green.betas,TypeI.Red.betas))
 
```

beta values:   | autosomes           |  sex chromosomes 
---------------|---------------------|----------------------------
dimension:     | $`r dim(beta.raw)`$ | $`r dim(beta.raw.sex)`$



