## PART 2 : lowlevel QC

The quality control consists of three parts: 

1. There is call-rate filtering with threshold $`r callrate.thres`$
2. The second part is based on control probes. Details are given in the [ILMN HD methylation assay protocol guide (15019519)](https://support.illumina.com/downloads/infinium_hd_methylation_assay_protocol_guide_(15019519_b).html).
3. The data is checked for sex mismatch. 


```{r}
datsamples <- read.table(file=samplesfile,header=T,as.is=T,sep="\t")
# remove samples not in samplesfile
samplesinclude <- intersect(names(sample.call),datsamples$Sample_ID)
sample.call <- sample.call[samplesinclude]
ctrl_complete.Green.all <- ctrl_complete.Green.all[,samplesinclude]
ctrl_complete.Red.all <- ctrl_complete.Red.all[,samplesinclude]
beta_sex <- beta_sex[,samplesinclude]

```

$`r length(samplesinclude)`$ samples are included in the analysis, identified by the samplefile and existing sample calls:

```{r}
datsamples$Sample_Name[datsamples$Sample_ID%in%samplesinclude]
```

```{r}
# call-rate filtering

samples.filtered <- data.frame()
bufout <- names(sample.call[sample.call<=callrate.thres])
if (length(bufout)>0) samples.filtered <- data.frame(sample=bufout,x=NA,y=NA,filter=paste0("callrate ",callrate.thres),stringsAsFactors=F)
```
  

* $`r length(bufout)`$ samples were tagged for exclusion because the call-rate was below the threshold $`r callrate.thres`$.


```{r}
#control probe based QC
# Details are given in the ILMN HD methylation assay protocol guide (15019519)

# bisulfate conversion: a non-CpG sequence with only one C at the target site will be converter to T by BS conversion. Therefore, converted control probes should be expressed (for each red/green channel) and unconverted not.
# BS-I
cprobes <- control_info[control_info$Type=="BISULFITE CONVERSION I" & (control_info$Color %in% c("Green","LimeGreen","Lime")),"Address"] # select converted green
controlQC <- data.frame(Cgreen=colMeans(ctrl_complete.Green.all[cprobes,]))
cprobes <- control_info[control_info$Type=="BISULFITE CONVERSION I" & (control_info$Color %in% c("Purple","Red","Tomato")),"Address"] # select converted red
controlQC <- cbind(controlQC,data.frame(Cred=colMeans(ctrl_complete.Red.all[cprobes,])))
cprobes <- control_info[control_info$Type=="BISULFITE CONVERSION I" & (control_info$Color %in% c("Blue","SkyBlue","Cyan")),"Address"] # select unconverted green
controlQC <- cbind(controlQC,data.frame(Ugreen=colMeans(ctrl_complete.Green.all[cprobes,])))
cprobes <- control_info[control_info$Type=="BISULFITE CONVERSION I" & (control_info$Color %in% c("Orange","Gold","Yellow")),"Address"] # select unconverted red
controlQC <- cbind(controlQC,data.frame(Ured=colMeans(ctrl_complete.Red.all[cprobes,])))

# BS-II (red intensity, green should be background level)
cprobes <- control_info[control_info$Type=="BISULFITE CONVERSION II","Address"] # select converted red
controlQC <- cbind(controlQC,data.frame(BSIIgreen=colMeans(ctrl_complete.Green.all[cprobes,])))
controlQC <- cbind(controlQC,data.frame(BSIIred=colMeans(ctrl_complete.Red.all[cprobes,])))

# hybridization + target removal: green channel only
cprobes <- control_info[grep("Hyb (High)",control_info$ExtendedType,value=F,fixed=T),"Address"] # select hyb high
controlQC <- cbind(controlQC,data.frame(HybH=ctrl_complete.Green.all[cprobes,]))
cprobes <- control_info[grep("Hyb (Low)",control_info$ExtendedType,value=F,fixed=T),"Address"] # select hyb low
controlQC <- cbind(controlQC,data.frame(HybL=ctrl_complete.Green.all[cprobes,]))
cprobes <- control_info[grep("Target Removal",control_info$ExtendedType,value=F,fixed=T),"Address"] # select target removals
controlQC <- cbind(controlQC,data.frame(TR=colMeans(ctrl_complete.Green.all[cprobes,])))

# specificity I
cprobes <- control_info[grep("GT Mismatch . \\(PM\\)",control_info$ExtendedType,value=F),"Address"] # select spec I signal
controlQC <- cbind(controlQC,data.frame(SpecIPMred=colMeans(ctrl_complete.Red.all[cprobes,]))) # specific match (red)
controlQC <- cbind(controlQC,data.frame(SpecIPMgreen=colMeans(ctrl_complete.Green.all[cprobes,]))) # specific match (green)
cprobes <- control_info[grep("GT Mismatch . \\(MM\\)",control_info$ExtendedType,value=F),"Address"] # select spec I signal
controlQC <- cbind(controlQC,data.frame(SpecIMMred=colMeans(ctrl_complete.Red.all[cprobes,]))) # specific match bg (red)
controlQC <- cbind(controlQC,data.frame(SpecIMMgreen=colMeans(ctrl_complete.Green.all[cprobes,]))) # specific match bg (green)

# specificity II
cprobes <- control_info[grep("Specificity ",control_info$ExtendedType,value=F),"Address"] # select spec II
controlQC <- cbind(controlQC,data.frame(SpecIIspec=colMeans(ctrl_complete.Red.all[cprobes,]))) # specific match (red)
controlQC <- cbind(controlQC,data.frame(SpecIIunspec=colMeans(ctrl_complete.Green.all[cprobes,]))) # unspecific match (green)

# extension
cprobes <- control_info[grep("Extension \\([CG]\\)",control_info$ExtendedType,value=F),"Address"] # select C,G (green)
controlQC <- cbind(controlQC,data.frame(ExtCG=colMeans(ctrl_complete.Green.all[cprobes,])))
cprobes <- control_info[grep("Extension \\([AT]\\)",control_info$ExtendedType,value=F),"Address"] # select A,T (red)
controlQC <- cbind(controlQC,data.frame(ExtAT=colMeans(ctrl_complete.Red.all[cprobes,])))

# staining red (DNP)/green (Biotin)
cprobes <- control_info[grep("DNP (High)",control_info$ExtendedType,value=F,fixed=T),"Address"] # select staining red
controlQC <- cbind(controlQC,data.frame(StainingRedH=ctrl_complete.Red.all[cprobes,]))
cprobes <- control_info[grep("Biotin (High)",control_info$ExtendedType,value=F,fixed=T),"Address"] # select staining green
controlQC <- cbind(controlQC,data.frame(StainingGreenH=ctrl_complete.Green.all[cprobes,]))
cprobes <- control_info[grep("DNP (Bkg)",control_info$ExtendedType,value=F,fixed=T),"Address"] # select staining red background
controlQC <- cbind(controlQC,data.frame(StainingRedB=ctrl_complete.Red.all[cprobes,]))
cprobes <- control_info[grep("Biotin (Bkg)",control_info$ExtendedType,value=F,fixed=T),"Address"] # select staining green background
controlQC <- cbind(controlQC,data.frame(StainingGreenB=ctrl_complete.Green.all[cprobes,]))

```

The first 3 rows of control probes information from QC contain the following information:

```{r}
controlQC[1:3,]
##
```

In the following control probes are checked. For a more detailed descriptin see e.g. the [ILMN HD methylation assay protocol guide (15019519)](https://support.illumina.com/downloads/infinium_hd_methylation_assay_protocol_guide_(15019519_b).html) or the [Illumina BeadArray Controls Reporter Software Guide ](https://support.illumina.com/downloads/beadarray-controls-reporter-software-guide-1000000004009.html),pages 6-8. Probes are evaluated by MA plots. BS-I and BS-II control probes check the DNA bisulfite conversion step.

```{r}
labels <- rownames(controlQC)
removeOutlier <- function(val1,val2,labels=NULL,xname="val1",yname="val2",title="",filterYout=1) {
    SDrange=4 # range to define outliers
    nullOffs=0.0001 # offset to avoid division by zero, log 0, etc.

    x <- log2(sqrt(val1*val2)+nullOffs)
    y <- log2((val1+nullOffs)/(val2+nullOffs))
    x.w <- x[which(x>log2(nullOffs))] # remove extreme values that are zero, i.e. for staining
    y.w <- y[which(x>log2(nullOffs))] # remove extreme values that are zero, i.e. for staining, remove them also from y (based on x-extremes)
    x.w <- Winsorize(x.w)
    y.w <- Winsorize(y.w)
    out <- which(x>mean(x.w)+sd(x.w)*SDrange) # upper X
    out <- c(out,which(x<mean(x.w)-sd(x.w)*SDrange)) # lower X
    if (filterYout==2) { out <- c(out,which(y>mean(y.w)+sd(y.w)*SDrange)) } # upper Y 
    out <- unique(c(out,which(y<mean(y.w)-sd(y.w)*SDrange))) # lower Y

    plot(x,y,xlab=bquote(log[2](sqrt(.(xname)%*%.(yname)))),ylab=bquote(log[2](.(xname)/.(yname))),main=title,xlim=c(min(x),max(x)+7))

    #plot(x,y,xlab=bquote(log[2](sqrt(.(xname)%*%.(yname)))),ylab=bquote(log[2](.(xname)/.(yname))),main=title,xlim=c(min(x),max(x)+7),col=as.numeric(as.factor(labels_ext$Sample_Group))+2) # test only

    points(x[out],y[out],col="red")
    if (length(out)>0) {
        text(x[out],y[out],label=labels[out],col="red",adj=c(0,0),cex=0.7)
    }

    ret <- data.frame(sample=labels[out],x=x[out],y=y[out])
    return(ret)
}

#pdf(paste0(outputdir,"/SampleQC.pdf"))

if(filterOutlierCtrlQC){
# BS I-C
bufout <- removeOutlier(controlQC$Cred,controlQC$Ured,labels,"Cred","Ured","BS-I C/U (red)")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="BS I-C (red)"))

# BS I-U
bufout <- removeOutlier(controlQC$Cgreen,controlQC$Ugreen,labels,"Cgreen","Ugreen","BS-I C/U (green)")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="BS I-C (green)"))

# BS II
bufout <- removeOutlier(controlQC$BSIIred,controlQC$BSIIgreen,labels,"BSIIred","BSIIgreen","BS-II (red vs. green)")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="BS II"))
}
```

We also check the Hybridisation of the amplified DNA to the array:

```{r}
if(filterOutlierCtrlQC){
# Hyb + TR
bufout <- removeOutlier(controlQC$HybH,controlQC$TR,labels,"HybH","TargetRemoval","Hybridization (green)")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Hyb_TR"))

# SpecI red
bufout <- removeOutlier(controlQC$SpecIPMred,controlQC$SpecIMMred,labels,"specific","unspecific","Specificity I (red)")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Specificity I (red)"))

# SpecI green
bufout <- removeOutlier(controlQC$SpecIPMgreen,controlQC$SpecIMMgreen,labels,"specific","unspecific","Specificity I (green)")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Specificity I (green)"))

# SpecII
bufout <- removeOutlier(controlQC$SpecIIspec,controlQC$SpecIIunspec,labels,"specific","unspecific","Specificity II")
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Specificity II"))

# Extension
bufout <- removeOutlier(controlQC$ExtCG,controlQC$ExtAT,labels,"ExtCG","ExtAT","Extensions",2) # both on upper and lower Y outlier
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Extensions"))

#par(mfrow=c(2,2))
nullOffs=0.0001 # use the same value as defined in removeOutlier() function!
# Staining Red (do not filter upper left cluster when checking csv file)
bufout <- removeOutlier(controlQC$StainingRedH,controlQC$StainingRedB,labels,"RedH","RedB","Staining (red) - Upper left cluster is OK!")
bufout <- bufout[which(bufout$x>log2(nullOffs) | bufout$y<=0),] # do not remove upper left cluster
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Staining Red (cross-check with Extension outliers!)"))

# Staining Green (do not filter upper left cluster when checking csv file)
bufout <- removeOutlier(controlQC$StainingGreenH,controlQC$StainingGreenB,labels,"GreenH","GreenB","Staining (green) - Upper left cluster is OK!")
bufout <- bufout[which(bufout$x>log2(nullOffs) | bufout$y<=0),] # do not remove upper left cluster
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Staining Green (cross-check with Extension outliers!)"))

# Staining Red vs. Green
bufout <- removeOutlier(controlQC$StainingRedH,controlQC$StainingGreenH,labels,"RedH","GreenH","Staining (red vs. green)",2) # both on upper and lower Y outlier
if (nrow(bufout)>0) samples.filtered <- rbind(samples.filtered,data.frame(bufout,filter="Staining Green_Red (cross-check with Extension outliers!)"))

plot(1,1,type="n",xaxt="n",yaxt="n",xlab="",ylab="",bty="n")
text(1,1,label="cross-check with Extension outliers!")
# par(mfrow=c(1,1))

if (nrow(samples.filtered)>0) {
    samples.filtered <- merge(samples.filtered,datsamples,all.x=T,by.x="sample",by.y="Sample_ID")
    samples.filtered <- merge(samples.filtered,data.frame(callrate=sample.call),all.x=T,by.x="sample",by.y=0)    
    samples.filtered <- samples.filtered[order(samples.filtered$sample,samples.filtered$filter),]
}
write.csv(samples.filtered,file = paste0(outputdir,"/samples-filtered","_",projectname,"-",formatted.time,".csv"),row.names=F)

}
```


The following table lists the detected outliers identified by the quality control and can be found 
in the file `r paste0(outputdir,"/samples-filtered.csv")` in a slightly expanded version. 

```{r}
if(nrow(samples.filtered) > 0){
	# remove redundant information
	posID = match("Sentrix_ID", colnames(samples.filtered))
	posPos = match("Sentrix_Position", colnames(samples.filtered))
	reduced.samples.filtered = samples.filtered[,-c(posID, posPos)]
	# find most interesting columns
	posName = match("Sample_Name", colnames(reduced.samples.filtered))
	posFilter = match("filter", colnames(reduced.samples.filtered))
	# print
	print(reduced.samples.filtered[,c(posName,posFilter)])
	print(reduced.samples.filtered[,-c(posName,posFilter)])
} else {
	cat("No samples were filtered.")
}
```

Gamete methylation can be used to check sex mismatches. First, we see the loadings of the PCA on markers in the space of samples. The second plot shows the principle components of the PCA on the samples in the space of samples.

```{r}
############## sex mismatch ##############

# Raw betas
sexprobes <- c(sexchrX,sexchrY) # chr X+Y

# EV NA omit
betaPCA <- beta_sex[sexprobes,]
pcaSex <- prcomp(na.omit(betaPCA))
EV <- pcaSex$rotation
EV <- merge(EV,datsamples,by.x=0,by.y="Sample_ID")

# plot first males, then females: find female outlier
idx = which(EV$Gender%in%c(1)) # 1 is female
plot(EV[-idx,"PC1"],EV[-idx,"PC2"],col=2, main=paste0("number of sex probes: ",nrow(betaPCA)," (RAW NA omitted)"),sub = "check for female outlier", xlab=paste0("EV1 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[1]*100),"%)"),ylab=paste0("EV2 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[2]*100),"%)"), xlim = c(min(EV[,"PC1"]),max(EV[,"PC1"])), ylim = c(min(EV[,"PC2"]),max(EV[,"PC2"])))
points(EV[idx,"PC1"],EV[idx,"PC2"],col=3)
legend("top", pch = c(1,1), col = c(3,2), legend = c("women","men"))

# then plot first females, then males: find male-outlier
plot(EV[idx,"PC1"],EV[idx,"PC2"],col=3, main=paste0("number of sex probes: ",nrow(betaPCA)," (RAW NA omitted)"),sub = "check for male outlier", xlab=paste0("EV1 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[1]*100),"%)"),ylab=paste0("EV2 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[2]*100),"%)"), xlim = c(min(EV[,"PC1"]),max(EV[,"PC1"])), ylim = c(min(EV[,"PC2"]),max(EV[,"PC2"])))
points(EV[-idx,"PC1"],EV[-idx,"PC2"],col=2)
legend("top", pch = c(1,1), col = c(3,2), legend = c("women","men"))


## old: plot both simultaneously
# plot(EV[,"PC1"],EV[,"PC2"],col=EV$Gender+2, main=paste0("number of sex probes: ",nrow(betaPCA)," (RAW NA omitted)"),xlab=paste0("EV1 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[1]*100),"%)"),ylab=paste0("EV2 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[2]*100),"%)"))
# legend("top", pch = c(1,1), col = c(3,2), legend = c("women","men"))

```


```{r}
resSexCheck <- data.frame(Sample_ID=EV$Row.names,Sex=EV$Gender,EV1=EV[,"PC1"],EV2=EV[,"PC2"])

# PC NA omit
betaPCA <- beta_sex[sexprobes,]
pcaSex <- prcomp(t(na.omit(betaPCA)))
EV <- pcaSex$x
EV <- merge(EV,datsamples,by.x=0,by.y="Sample_ID")

# plot first males, then females: find female outlier
idx = which(EV$Gender%in%c(1)) # 1 is female
plot(EV[-idx,"PC1"],EV[-idx,"PC2"],col=2, main=paste0("number of sex probes: ",nrow(betaPCA)," (RAW NA omitted)"),sub = "check for female outlier", xlab=paste0("PC1 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[1]*100),"%)"),ylab=paste0("PC2 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[2]*100),"%)"), xlim = c(min(EV[,"PC1"]),max(EV[,"PC1"])), ylim = c(min(EV[,"PC2"]),max(EV[,"PC2"])))
points(EV[idx,"PC1"],EV[idx,"PC2"],col=3)
legend("top", pch = c(1,1), col = c(3,2), legend = c("women","men"))

# then plot first females, then males: find male-outlier
plot(EV[idx,"PC1"],EV[idx,"PC2"],col=3, main=paste0("number of sex probes: ",nrow(betaPCA)," (RAW NA omitted)"),sub = "check for male outlier", xlab=paste0("PC1 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[1]*100),"%)"),ylab=paste0("PC2 (",sprintf("%1.1f",(pcaSex$sdev^2/sum(pcaSex$sdev^2))[2]*100),"%)"), xlim = c(min(EV[,"PC1"]),max(EV[,"PC1"])), ylim = c(min(EV[,"PC2"]),max(EV[,"PC2"])))
points(EV[-idx,"PC1"],EV[-idx,"PC2"],col=2)
legend("top", pch = c(1,1), col = c(3,2), legend = c("women","men"))

resSexCheck <- cbind(resSexCheck,data.frame(PC1=EV[,"PC1"],PC2=EV[,"PC2"]))
write.csv(resSexCheck,file = paste0(outputdir,"/results-PCAsex_raw","_",projectname,"-",formatted.time,".csv"),row.names=F,quote=F)
```


```{r}
# plot sample call rates
hist(sample.call,breaks=100, main = "sample call rates")
```

```{r}
# plot sample call rates
hist(sample.call,breaks=100, main = "sample call rates zoomed", xlim = c(0.85,1))
```
  

$`r max(0,length(sample.call[which(sample.call<=0.98)]))`$ of all sample call rates are lower than 0.98,  
 and $`r length(sample.call[which(sample.call<=callrate.thres)])`$ are lower than the threshold $`r callrate.thres`$.

```{r}
hist(marker.call,breaks=100, main = "marker call rates")
#dev.off()
```
  

$`r max(0,length(marker.call[which(marker.call<=0.98)]))`$ of all marker call rates are lower than 0.98,  
 and $`r length(marker.call[which(marker.call<=0.95)])`$ are lower than the threshold 0.95.



The previous calculations provide all information needed to filter the samples and make a tab-separated file *samplesfilefinal* for further use. 
For this analysis, `r samplesfilefinal` was used as list of samples for the final preprocessing steps. 

```{r}
plot.beta.densities = function(beta, title){
	densities = apply(beta,2,function(x){ density(x, na.rm = TRUE) } )
	xmax = max(sapply(densities, function(d){max(d$x)}))
	xmin = min(sapply(densities, function(d){min(d$x)}))
	ymax = max(sapply(densities, function(d){max(d$y)}))

	plot(NA, xlim = c(xmin,xmax), ylim = c(0,ymax), main = title, ylab = "")
	colors = rainbow(10)
	for(i in 1:ncol(beta)){
		lines(densities[[i]], col = colors[i%%10 + 1])
	}

}
plot.beta.densities(beta.raw,"Densities of raw autosomal beta values per sample")
```
  

