```{r, label = declare_detP_function, echo = FALSE}
detectionP.local <- function (rgSet, type = "m+u")
{
    locusNames <- getManifestInfo(rgSet, "locusNames")
    detP <- matrix(NA_real_, ncol = ncol(rgSet), nrow = length(locusNames),
        dimnames = list(locusNames, sampleNames(rgSet))) 
    controlIdx <- getControlAddress(rgSet, controlType = "NEGATIVE")
    r <- getRed(rgSet)
    rBg <- r[controlIdx, ]
    rMu <- colMedians(rBg)
    rSd <- colMads(rBg)
    g <- getGreen(rgSet) 
    gBg <- g[controlIdx, ]
    gMu <- colMedians(gBg)
    gSd <- colMads(gBg)
    TypeII <- getProbeInfo(rgSet, type = "II")
    TypeI.Red <- getProbeInfo(rgSet, type = "I-Red")
    TypeI.Green <- getProbeInfo(rgSet, type = "I-Green")

    minSd <- 0.000001
    for (i in 1:ncol(rgSet)) {
        # change sd to min 0.000001
        intensity <- r[TypeI.Red$AddressA, i] + r[TypeI.Red$AddressB, i]
        detP[TypeI.Red$Name, i] <- 1 - pnorm(intensity, mean = rMu[i] * 2, sd = max(rSd[i],minSd) * 2)
        intensity <- g[TypeI.Green$AddressA, i] + g[TypeI.Green$AddressB, i] 
        detP[TypeI.Green$Name, i] <- 1 - pnorm(intensity, mean = gMu[i] * 2, sd = max(gSd[i],minSd) * 2)
        intensity <- r[TypeII$AddressA, i] + g[TypeII$AddressA, i]
        detP[TypeII$Name, i] <- 1 - pnorm(intensity, mean = rMu[i] + gMu[i], sd = max(rSd[i] + gSd[i],minSd))
    }
    detP
}
```

## PART 1: Data and parameters

```{r, label='read-in.samples', message = FALSE, echo = FALSE, warning = FALSE}

##########################################
# read samples ###########################
datsamples <- read.table(file=samplesfile,header=T,as.is=T,sep="\t", colClasses = "character")

# check columns
if("male"%in%colnames(datsamples)&!"Sex_female"%in%colnames(datsamples)){datsamples$Sex_female <- as.numeric(abs(1 - as.numeric(datsamples$male)))}
if(!all(c("Sentrix_ID","Sentrix_Position","Sex_female")%in%colnames(datsamples))){stop("samplesfile must provide Sex_female, Sentrix_ID and Sentrix_Position.")}

datsamples$Sex_female = as.numeric(datsamples$Sex_female)
# provide a new column with sample identifier
datsamples$Sentrix_Code = paste(datsamples$Sentrix_ID,datsamples$Sentrix_Position,sep = "_")
# datsamples$MFSex_female = ifelse(datsamples$Sex_female == 0, "M","F")

# read final samples #####################
datsamplesfinal <- read.table(file=samplesfilefinal,header=T,as.is=T,sep="\t", colClasses = "character")

# check columns
if("male"%in%colnames(datsamplesfinal)&!"Sex_female"%in%colnames(datsamplesfinal)){datsamplesfinal$Sex_female <- as.numeric(abs(1 - as.numeric(datsamplesfinal$male)))}
if(!all(c("Sentrix_ID","Sentrix_Position","Sex_female")%in%colnames(datsamplesfinal))){stop("Final samplesfile must provide Sex_female, Sentrix_ID and Sentrix_Position.")}

datsamplesfinal$Sex_female = as.numeric(datsamplesfinal$Sex_female)
# provide a new column with sample identifier
datsamplesfinal$Sentrix_Code = paste(datsamplesfinal$Sentrix_ID,datsamplesfinal$Sentrix_Position,sep = "_")
# datsamplesfinal$MFSex_female = ifelse(datsamplesfinal$Sex_female == 0, "M","F")
##########################################

```


```{r, label='read-in.methylation', message = FALSE, echo = FALSE, warning = FALSE}

# read data ###############################
 
cwd<-getwd()

scandata <- strsplit(idatdir,";")[[1]]

# this could be a way to sort arraytypes to data paths // assumingly not necessary as updated functions will be able to detect arraytype themselves
# arraytypes_pathwise <- strsplit(arraytypes_pathwise,";")[[1]]
# names(arraytypes_pathwise) <- scandata


filenames_pathwise <- vector(mode = "list", length = length(scandata))
names(filenames_pathwise) <- scandata

RGset_pathwise <- vector(mode = "list", length = length(scandata))
names(RGset_pathwise) <- scandata

sample_names <- NA
missing_idat <- NA
samplesheet_combined <- merge(datsamples, datsamplesfinal)

######## FILENAMES ###################

for(path in scandata){ # all files in the same path have to have identical array built - they are merged later
	 setwd(path)
		
	files_here <- dir(path = path, pattern="\\.idat$",recursive=TRUE, full.names=TRUE) # this path handling ensures correct number of / in path name
	filenames_pathwise[[path]] <- unique(gsub("_Grn.idat","",gsub("_Red.idat","",files_here,ignore.case=T),ignore.case=T))

	sample_names = c(sample_names, sapply(filenames_pathwise[[path]], function(s){sub(".+/","",s)}))
	
	rm(files_here)

	filenames <- filenames_pathwise[[path]]

	# filter filenames list with combined samples of samplesfile and samplesfile_final
	# look which samples of all are in this path
 	 filenames_idx_list <- sapply(union(datsamplesfinal$Sentrix_Code,datsamples$Sentrix_Code), function(x){grep(x,filenames)})
	 filenames_idx <-  as.integer(filenames_idx_list)
	 	
	# need unique NA-free index 
	 filenames_idx <- filenames_idx[!is.na(filenames_idx)]

 	filenames = filenames[filenames_idx] # !! this changes filenames object! 
 	filenames_pathwise[[path]] <- filenames
	# filenames <- filenames[1:5] # test version

}

# make one filenames object to merge 
	filenames_all <- unlist(filenames_pathwise)
	samplesheet_combined$filename <- as.character(sapply(samplesheet_combined$Sentrix_Code, function(x){grep(x,filenames_all, value = TRUE)})) 

	 # protocol samples without idat file
	 filenames_all_idx_list <- sapply(union(datsamplesfinal$Sentrix_Code,datsamples$Sentrix_Code), function(x){grep(x,filenames_all)})
	 filenames_all_idx <-  as.integer(filenames_all_idx_list)
	 missing_idat <- names(filenames_all_idx_list[is.na(filenames_all_idx)])

	if(length(missing_idat) > 0){
		write.table(missing_idat, file = paste0(outputdir,"/missing_idat_files","_",projectname,"-",formatted.time,".tsv"), row.names = FALSE, append = TRUE) 
	}


####### METHYLATION READ-IN #####################

for(path in scandata){ # all files in the same path have to have identical array built - they are merged later
	
	# restrict the samplesheet to the samples we found in this path 
  	samplesheet_local <- samplesheet_combined[grep(path, samplesheet_combined$filename),]
 	samplesheet_local$Basename <- samplesheet_local$filename
	RGset = read.metharray.exp(targets = samplesheet_local, recursive = TRUE, force = TRUE) # need force in EPIC(v1) idats only, not a v1-v2 problem
 		
 		 annotation(RGset)["array"] = "IlluminaHumanMethylationEPIC" 
 		# switch to EPIC only to make bgcorrect.illumina and wbc.est work; however it then loads the wrong manifest in future functions; EPICv2 seems not defined
 		# the function should work exactly as it should be because the arraytype only determines the name of the column of probes.
 		# Having the right column name, the probes are still EPICv2-specific not EPIC (v1) downgrade. 
 		
	## process RGset object seperately for EPIC v1.3 and v2.0 (background correction, samplewise functions like WBC estimation, SNP extraction, control probe quality control)
	## arrays are merged at PROBE INFO & DATA SPLIT
	
	RGset <- bgcorrect.illumina(RGset)  # Illumina background subtraction # doesnt work on minfi 1.50.0 EPIC v2 (yet, 06/2024) 
	# since the control descriptor seems to be the only difference between arrays, but 
	# is the same for EPIC and EPICv2 I state that handling the EPICv2 RGset as an EPIC in bgcorrect returns the correct result;
	# see function details and getProbeInfo(dat, "Control")
	
	RGset_pathwise[[path]] <- RGset
	
	rm(RGset)

} ######## data read-in 


######## WBC and SNP extraction ####################
	
	# NOTE No need to make WBC estimation on final samples only since WBC estimation is sample-wise.
	# But I recommend to do it in last-but-one cleanup step with final samples as only input to save computational effort.

WBCok = ifelse(exists("estimateWBCs"), estimateWBCs, FALSE)

# produces Error in get(referencePkg) : object 'FlowSorted.Blood.EPIC' not found >> run manually on lower R version? update estimateCellCounts function? 
if(WBCok%in%TRUE){ # use EPIC (v1) reference platform to get the best to-date estimation; should be fairly ok esp. for the combined analysis
	print("WBC estimation is currently disabled.") }
# 		
# # do this pathwise == arraywise 
# estwbc_pathwise <- vector(mode = "list", length = length(scandata))
# names(estwbc_pathwise) <- scandata
# 
# 
# for(path in scandata){ # all files in the same path have to have identical array built - they are merged later
# 
# 	RGset <- RGset_pathwise[[path]] 
# 
#  	estwbc_pathwise[[path]] <- estimateCellCounts(RGset, compositeCellType = "Blood", cellTypes = c("CD8T","CD4T", "NK","Bcell","Mono","Gran"),
#  				 sex = datsamples$MFSex_female[match(sample_names,datsamples$Sentrix_Code)],
#  				 referencePlatform = c("IlluminaHumanMethylationEPIC")
#  				 )
# 		########################################
#  		# comment by Lucas Salas on github: If you are using the latest version of FlowSorted.Blood.EPIC (>=v.2.0) you do not need to specify any of those options.
#  		# >> update to estimateCellCounts2
#  		###########################################
# 
#  				 
#  	rm(RGset)
#  
# } # end of RGset-wise wbc est 
# 
# # combine wbc estimation
# 
# est_wbc <- do.call("rbind", estwbc_pathwise)
#  	                              
# } # end of WBC estimation

#### SNP extraction ## EPICv2 comment: works theoretically, but too low output
		
if(exists("extractSNPs")){ 
	if(extractSNPs%in%"TRUE"){

	## do this pathwise == arraywise 
	snps_pathwise <- vector(mode = "list", length = length(scandata))
	names(snps_pathwise) <- scandata

	 for(path in scandata){ # all files in the same path have to have identical array built - they are merged later
 
	 	RGset <- RGset_pathwise[[path]] 
	 
	  	snps_pathwise[[path]] <- getSnpBeta(RGset) 
	  	snps_pathwise[[path]] <- as.data.frame(snps_pathwise[[path]])
	  	snps_pathwise[[path]]$rsID <- rownames(snps_pathwise[[path]])

       		 if(exists("snp.extraction")){
       		     snp.extraction <- merge(snp.extraction, snps_pathwise[[path]] , by = "rsID", all = TRUE)
       		 } else {
       		     snp.extraction <- snps_pathwise[[path]]
       		 }
       	 	
	 	rm(RGset)
	 
	 } # end of RGset-wise snp extraction for loop
       		 
	} # end of TRUE snp extraction
} # end of exists snp extraction


########### PROBE INFO & DATA SPLIT ###############################################

# this is what we need and merge in the end 

	TypeII.Red_pathwise <- vector(mode = "list", length = length(scandata))
		names(TypeII.Red_pathwise) <- scandata
	TypeII.Green_pathwise <- vector(mode = "list", length = length(scandata))
		names(TypeII.Green_pathwise) <- scandata
	TypeI.Green.M_pathwise <- vector(mode = "list", length = length(scandata))
		names(TypeI.Green.M_pathwise) <- scandata
	TypeI.Green.U_pathwise <- vector(mode = "list", length = length(scandata))
		names(TypeI.Green.U_pathwise) <- scandata
	TypeI.Red.U_pathwise <- vector(mode = "list", length = length(scandata))
		names(TypeI.Red.U_pathwise) <- scandata
	TypeI.Red.M_pathwise <- vector(mode = "list", length = length(scandata))
		names(TypeI.Red.M_pathwise) <- scandata

# control probes for lowlevel QC - might be processed seperately or together

	ctrl_pathwise <- vector(mode = "list", length = length(scandata))
		names(ctrl_pathwise) <- scandata
	ctrl.complete.Red_pathwise <- vector(mode = "list", length = length(scandata))
		names(ctrl.complete.Red_pathwise) <- scandata
	ctrl.complete.Green_pathwise <- vector(mode = "list", length = length(scandata))
		names(ctrl.complete.Green_pathwise) <- scandata
	
	dp_pathwise <- vector(mode = "list", length = length(scandata))
		names(dp_pathwise) <- scandata


for(path in scandata){ # all files in the same path have to have identical array built - they are merged later
 
	RGset <- RGset_pathwise[[path]] 
 
	# Type II probes
	TypeII.Name <- getProbeInfo(RGset, type = "II")$Name
	
	# manual data reading of rg set object : head(assay(rg, "Green")) 
	# is the same kind of data (below: rg = EPIC2, RGset = EPIC1), matching the names needs the annotation file
	# this is AddressA_ID / AddressB_ID column in annotationfile 
	# delete potentially leading zeros or expect leading zeros in annotationfile
	
	# first column number of TypeII.Green down there:
	# franziskag-c@Franziskas-MacBook-Air CPACOR-EPIC_pipeline % grep 85713262 annotationfileB4_2017-09-15.csv 
	# cg07881041,cg07881041,0085713262,CTACAAATACAACACCCTCAACCCATATTTCATATATTATCTCATTTAAC,,,II,,,CTGC..[etc,etc]
	
	# and respectively for EPICv2
# 	franziskag-c@Franziskas-MacBook-Air CPACOR-EPIC_pipeline % grep ,1600157, MethylationEPIC_v2.0_Files/EPIC-8v2-0_A1.csv 
#   cg08151515_TC21,cg08151515,1600157,CACCTCRTACTCATCAAAATAACCTCTATCAAAAATCCAAAAACAACAAC,,,,,,cg,R,T,C,2,II,chr6,2636911,Human,GRCh38,CGTTGTTGTTTCTGGATTTTTGACAGAGG

# > head(assay(rg, "Green")) # this in TypeI and TypeII !
#         207810890008_R01C01 207810890120_R01C01 207831660084_R01C01
# 1600157                7807                7351                7782
# 1600179                3691                4366                5991
# 1600219                4207                6208                7367
# 1600225                6667                5721                6145
# 1600283                 213                 303                 442
# 1600411                4914                6001                7018

# this is the object we want to build, read-in from EPICv1
# RGset <- RGset_pathwise[[1]] 
# > TypeII.Green <- getGreen(RGset)[getProbeInfo(RGset, type = "II")$AddressA,]
# > head(TypeII.Green)
#          202073180065_R05C01 202073200086_R06C01 205537620061_R06C01
# 85713262               10321               12052                4200
# 21717843                3980                4452                1441
# 29622133                5695                5883                2451
# 16681196                 318                 538                 168
# 7767973                 5017                5365                1963
# 25809572                  65                  84                  47
# TypeII.Name <- getProbeInfo(RGset, type = "II")$Name
# rownames(TypeII.Green) <- TypeII.Name

# try building it on EPICv1: 
### what we do in EPICv2 is TypeII.Green <- assay(RGset, "Green") 
# TypeII.Green <- getGreen(RGset)[getProbeInfo(RGset, type = "II")$AddressA,]
# t2g <- as.data.frame(TypeII.Green)
# t2g$cg <- TypeII.Name
# annotationfile
# [1] "/data/programs/pipelines/CPACOR-EPIC_pipeline/annotationfileB4_2017-09-15.csv"
# > anno=read.csv("/data/programs/pipelines/CPACOR-EPIC_pipeline/annotationfileB4_2017-09-15.csv",as.is=TRUE, skip = 7)
# t2g$Name <- anno$Name[match(rownames(t2g),gsub("^.[0]","", anno$AddressA_ID))]
# > sum(is.na(t2g$Name))
# [1] 84563
# > sum(is.na(t2g$cg)) # == TypeII.Name the sites which the built-in function returns
# [1] 0
# > identical(t2g$Name[!is.na(t2g$Name)],t2g$cg[!is.na(t2g$Name)])
# [1] TRUE
# >>> works, but not for all sites, on EPICv1
# t2g$IlmnID <- anno$IlmnID[match(rownames(t2g),gsub("^.[0]","", anno$AddressA_ID))] # has identical missings


# try on EPICv2
# anno = read.csv("/data/programs/pipelines/CPACOR-EPIC_pipeline/MethylationEPIC_v2.0_Files/EPIC-8v2-0_A1.csv", as.is=TRUE, skip = 7)
# 	rg <- RGset_pathwise[[2]]
# 	TypeII.Green <- getGreen(rg)[getProbeInfo(rg, type = "II")$AddressA,] # >> Error in getGreen(rg)[getProbeInfo(rg, type = "II")$AddressA, ] : subscript out of bounds
# TypeII.probe <- anno$AddressA_ID[anno$Infinium_Design_Type == "II"]
# TypeII.probe.number <- gsub("^.[0]","", TypeII.probe)
# available <- intersect(rownames(assay(rg, "Green")),TypeII.probe.number)
# TypeII.Green <- assay(rg, "Green")[available,]
# t2g2 <- as.data.frame(TypeII.Green)
# t2g2$Name <- anno$Name[match(rownames(t2g2),gsub("^.[0]","", anno$AddressA_ID))]
# sum(is.na(t2g2$Name))


----------
# works for one type, it should work for all types
# hint on control data: annotationfile has a list of probes with Ilmn_ID etc and then an empty line which only says "CONTROLS" or "CONTROL" in the first column; the following probes are the control probes;
# actually it may be easier for manual handling to split the annotationfile into data and controls in the first place and read them in separately
# then they dont get mixed up in the pipelines
----------
	
	TypeII.Green <- getGreen(RGset)[getProbeInfo(RGset, type = "II")$AddressA,]
	TypeII.Red <- getRed(RGset)[getProbeInfo(RGset, type = "II")$AddressA,]
	rownames(TypeII.Red) <- TypeII.Name
	colnames(TypeII.Red) <- sampleNames(RGset)
	rownames(TypeII.Green) <- TypeII.Name
	colnames(TypeII.Green) <- sampleNames(RGset)

	# Type I probes, split into green and red channels
	TypeI.Green.Name <- getProbeInfo(RGset, type = "I-Green")$Name
	TypeI.Green.M <- getGreen(RGset)[getProbeInfo(RGset, type = "I-Green")$AddressB,]
	rownames(TypeI.Green.M) <- TypeI.Green.Name
	colnames(TypeI.Green.M) <- sampleNames(RGset)
	TypeI.Green.U <- getGreen(RGset)[getProbeInfo(RGset, type = "I-Green")$AddressA,]
	rownames(TypeI.Green.U) <- TypeI.Green.Name
	colnames(TypeI.Green.U) <- sampleNames(RGset)

	TypeI.Red.Name <- getProbeInfo(RGset, type = "I-Red")$Name
	TypeI.Red.M <- getRed(RGset)[getProbeInfo(RGset, type = "I-Red")$AddressB,]
	rownames(TypeI.Red.M) <- TypeI.Red.Name
	colnames(TypeI.Red.M) <- sampleNames(RGset)
	TypeI.Red.U <- getRed(RGset)[getProbeInfo(RGset, type = "I-Red")$AddressA,]
	rownames(TypeI.Red.U) <- TypeI.Red.Name
	colnames(TypeI.Red.U) <- sampleNames(RGset)

	TypeII.Red_pathwise[[path]] <- TypeII.Red
	TypeII.Green_pathwise[[path]] <- TypeII.Green
	TypeI.Red.M_pathwise[[path]] <- TypeI.Red.M
	TypeI.Red.U_pathwise[[path]] <- TypeI.Red.U
	TypeI.Green.M_pathwise[[path]] <- TypeI.Green.M
	TypeI.Green.U_pathwise[[path]] <- TypeI.Green.U

}

for(path in scandata){ # all files in the same path have to have identical array built - they are merged later
 
	RGset <- RGset_pathwise[[path]] 

	control=getProbeInfo(RGset, type = "Control") # needed also for lowlevel QC

	#BSC1 control probes - 450k: 16:18 ### 1:18 sind f??r 45ok die Zeilen control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Green","LimeGreen","Lime")) 
        BSCI.Green.Name = control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Green","LimeGreen","Lime")),]$ExtendedType
        BSCI.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(BSCI.Green.Name), dimnames = list(BSCI.Green.Name, sampleNames(RGset)))
        BSCI.Green[BSCI.Green.Name,] <- getGreen(RGset)[control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Green","LimeGreen","Lime")),]$Address,]
        # 450k: 22:24 ### 22:24 entsprechen control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Purple","Red","Tomato"))
        BSCI.Red.Name = control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Purple","Red","Tomato")),]$ExtendedType
        BSCI.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(BSCI.Red.Name), dimnames = list(BSCI.Red.Name, sampleNames(RGset)))
        BSCI.Red[BSCI.Red.Name,] <- getRed(RGset)[control[control$Type=="BISULFITE CONVERSION I" & (control$Color %in% c("Purple","Red","Tomato")),]$Address,]

        #BSC2 control probes - 450k: 28:31 ### s.o. 
        BSCII.Red.Name = control[control$Type=="BISULFITE CONVERSION II",]$ExtendedType
        BSCII.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(BSCII.Red.Name), dimnames = list(BSCII.Red.Name, sampleNames(RGset)))
        BSCII.Red[BSCII.Red.Name,] <- getRed(RGset)[control[control$Type=="BISULFITE CONVERSION II",]$Address,]
	
		# select control probes green channel by ExtendedType:
        # STAINING, EXTENSION, HYBRIDISATION, TARGET REMOVAL, Specificity I+II, NON POLYMORPHIC
        extendedTypeGreen=c("Biotin (High)","Extension (C)","Extension (G)","Hyb (High)","Hyb (Medium)","Hyb (Low)","Target Removal 1","Target Removal 2","GT Mismatch 1 (PM)","GT Mismatch 2 (PM)","GT Mismatch 3 (PM)","NP (C)","NP (G)")
        extendedTypeRed=c("DNP (High)","Extension (A)","Extension (T)","GT Mismatch 4 (PM)","GT Mismatch 5 (PM)","GT Mismatch 6 (PM)","Specificity 1","Specificity 2","Specificity 3","NP (A)","NP (T)")

        controlExtGreen <- control[control$ExtendedType %in% extendedTypeGreen,]
        controlExtRed <- control[control$ExtendedType %in% extendedTypeRed,]

        ctlext.Red.Name = controlExtRed$ExtendedType
        ctlext.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(ctlext.Red.Name), dimnames = list(ctlext.Red.Name, sampleNames(RGset)))
        ctlext.Red[ctlext.Red.Name,] <- getRed(RGset)[controlExtRed$Address,]
        ctlext.Green.Name = controlExtGreen$ExtendedType
        ctlext.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(ctlext.Green.Name), dimnames = list(ctlext.Green.Name, sampleNames(RGset)))
        ctlext.Green[ctlext.Green.Name,] <- getGreen(RGset)[controlExtGreen$Address,]

	### the upper selection of information of extended type is in a more condensed form by AT ; normalization has to be added by hand 

	# Normalisation
	normC.Green.Name=control[control[,2]=='NORM_C',4]
	normC.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normC.Green.Name), dimnames = list(normC.Green.Name, sampleNames(RGset)))
	normC.Green[normC.Green.Name,] <- getGreen(RGset)[control[control[,2]=='NORM_C',1],]
	normG.Green.Name=control[control[,2]=='NORM_G',4]
	normG.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normG.Green.Name), dimnames = list(normG.Green.Name, sampleNames(RGset)))
	normG.Green[normG.Green.Name,] <- getGreen(RGset)[control[control[,2]=='NORM_G',1],]
	normA.Red.Name=control[control[,2]=='NORM_A',4]
	normA.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normA.Red.Name), dimnames = list(normA.Red.Name, sampleNames(RGset)))
	normA.Red[normA.Red.Name,] <- getRed(RGset)[control[control[,2]=='NORM_A',1],]
	normT.Red.Name=control[control[,2]=='NORM_T',4]
	normT.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = length(normT.Red.Name), dimnames = list(normT.Red.Name, sampleNames(RGset)))
	normT.Red[normT.Red.Name,] <- getRed(RGset)[control[control[,2]=='NORM_T',1],]
	
	### here is code added for lowlevel QC (until combine ctrl probe intensities)
	
	# added for lowlevel QC
        #build dataframe with all control probes
        bufR <- intersect(rownames(getRed(RGset)),control[,1])
        bufG <- intersect(rownames(getGreen(RGset)),control[,1])
        control_ok.Red <- control[control[,1] %in% bufR,] # some controls seem to be in annotation file but not on array
        control_ok.Green <- control[control[,1] %in% bufG,] # some controls seem to be in annotation file but not on array

        # added for lowlevel QC
        # controls probes for red and green channel
        ctrl.complete.Red <- matrix(NA_real_, ncol = ncol(RGset), nrow = nrow(control_ok.Red), dimnames = list(control_ok.Red[,4], sampleNames(RGset)))
        ctrl.complete.Red <- getRed(RGset)[control_ok.Red[,1],]
        ctrl.complete.Green <- matrix(NA_real_, ncol = ncol(RGset), nrow = nrow(control_ok.Green), dimnames = list(control_ok.Green[,4], sampleNames(RGset)))
        ctrl.complete.Green <- getGreen(RGset)[control_ok.Green[,1],]
	
	#combine ctrl probe intensities ### shorter 
        ctrl = rbind(as.matrix(BSCI.Green), as.matrix(BSCI.Red), as.matrix(BSCII.Red), (ctlext.Red), (ctlext.Green),as.matrix(normC.Green),as.matrix(normG.Green), as.matrix(normA.Red),as.matrix(normT.Red))
		ctrl <- t(ctrl)

	#detection p-values
		dp = detectionP.local(RGset, type = "m+u") 
	
	# save
	ctrl_pathwise[[path]] <- ctrl
	ctrl.complete.Red_pathwise[[path]] <- ctrl.complete.Red
	ctrl.complete.Green_pathwise[[path]] <- ctrl.complete.Green
	
	dp_pathwise[[path]] <- dp

}

#### MERGE #####
# Todo need to merge instead of cbind, because dimensions differ

TypeII.Red.All <- do.call("cbind",TypeII.Red_pathwise)
TypeII.Green.All <- do.call("cbind",TypeII.Green_pathwise)
TypeI.Green.M.All <- do.call("cbind",TypeI.Green.M_pathwise)
TypeI.Green.U.All <- do.call("cbind",TypeI.Green.U_pathwise)
TypeI.Red.M.All <- do.call("cbind",TypeI.Red.M_pathwise)
TypeI.Red.U.All <- do.call("cbind",TypeI.Red.U_pathwise)

ctrl.all <- do.call("rbind",ctrl_pathwise) # need to transpose? 

## added for lowlevel QC by AT 
ctrl.complete.Red.all <- do.call("cbind", ctrl.complete.Red_pathwise) # added for lowlevel QC
ctrl.complete.Green.all <- do.call("cbind", ctrl.complete.Green_pathwise) # added for lowlevel QC
    
dp.all <- do.call("cbind",dp_pathwise)


# list(ls()) # remove what is not needed anymore - save space 
# rm( # list=ls(*_pathwise) # )
rm(BSCI.Green ,BSCI.Red ,BSCII.Red ,ctlext.Red ,ctlext.Green ,normC.Green ,normG.Green ,normA.Red ,normT.Red)
rm(bufR, bufG, control_ok.Red, control_ok.Green, ctrl.complete.Red, ctrl.complete.Green, TypeII.Red, TypeII.Green, TypeI.Red.M, TypeI.Red.U, TypeI.Green.M, TypeI.Green.U)
rm(dp, detppre, controlExtRed, controlExtGreen, extendedTypeGreen, extendedTypeRed, filenames_idx_list, filenames_idx, i, rawtypepre)
rm(BSCI.Green.Name, BSCI.Red.Name, BSCII.Red.Name, ctlext.Red.Name, ctlext.Green.Name, normC.Green.Name, normG.Green.Name, normA.Red.Name, normT.Red.Name)
rm(detectionP.local)
rm(RGset)

setwd(cwd)	

# save.image("test_runbyhand.Rdata")
```

### Read data and parameters

We are working with data from directory 
`r paste(strsplit(idatdir, split = "/")[[1]][-1], collapse = "/ ")` 
which contains $`r length(filenames) `$ idat files.
The annotationfile used is 
`r paste(strsplit(annotationfile, split = "/")[[1]][-1], collapse = "/ ")`
 - if problems occur with annotation, please have a look at [Illumina downloads](https://support.illumina.com/array/downloads.html)    *Infimum Methylation EPIC Product files*. 


Output is directed to  `r paste(strsplit(outputdir,split = "/")[[1]][-1], collapse = "/ ")`.
 We use samples listed in `r paste(strsplit(samplesfile, split = "/")[[1]][-1], collapse = "/ ")`\newline
  for quality control. 

As given in *parameterfile.R*, the following parameters were used: 

parameter                     | value
------------------------------|-------------------------------------
arraytype                     | `r arraytype`
detPthreshold                 | $`r detPthreshold`$
callrate.thres                | $`r callrate.thres`$
filterOutlierCtrlQC           | `r filterOutlierCtrlQC`
QuantileNormalize             | `r QuantileNormalize`
InterQuartileRangeCalculation | `r InterQuartileRangeCalculation`
estimateWBCs                  | `r ifelse(exists("estimateWBCs"),estimateWBCs, "not provided, assumed FALSE")`
extractSNPs                   |  `r ifelse(exists("extractSNPs"),extractSNPs, "not provided, assumed FALSE")`

Further we interpret the values for the Sex_female in the samplesfile as **1=female** and **0=male**. 

InterQuartileRange calculation depends on QuantileNormalisation, therefore Quantile Normalize is set to TRUE, if InterQuartileRangeCalculation is requested. 

```{r}
if(InterQuartileRangeCalculation == TRUE){
	QuantileNormalize <- TRUE
}

if(QuantileNormalize == TRUE && length(samplesfilefinal)==0){
	cat("In order to run Part 3: Quantile normalization and IQ-filter a final samplefile is needed.\n The samplesfile of the first and second part will be used instead.")
	samplesfilefinal <- samplesfile
}
path_depth<-length(strsplit(samplesfilefinal, split = "/")[[1]])
if(QuantileNormalize == TRUE){cat(paste0("The samples listed in\n", paste(strsplit(samplesfilefinal, split = "/")[[1]][2:(path_depth-3)], collapse = "/"),"/\n",paste0(strsplit(samplesfilefinal, split = "/")[[1]][(path_depth-2):path_depth], collapse = "/"),"\n are used for quantile normalization and calculation of outliers regarding inter-quartile-range."))}
```

When reading the data using the minfi-package we apply Illumina Background correction.
Within this process we also 

* extract control-probe information. 
* calculate detection p-values.
* estimate the white blood cell distribution assuming whole blood samples using minfi.
* separate the data by channel (red / green) and Infinium I / II type.

We use this detection p-values and control probe information for high-level quality control and the white blood cell estimations for further processing as phenodata.

### White Blood Cell estimation

If the switch estimateWBCs is set to TRUE in the parameterfile, white blood cell distributions are estimated assuming measurements from whole blood.
The estimation of White Blood Cells results in a data.frame est.wbc.minfi for further use as part of the phenodata.\newline
*Notice*: Dependencies of the results on the sample selection is possible. To avoid that the WBC estimation of fine runs is disturbed by problematic measurements, the estimation is based on samples from the final sample file only.

```{r} 
if(exists("est.wbc.minfi")){
     head(est.wbc.minfi)
}

```

### SNP data extraction

If the switch extractSNPs is set to TRUE in the parameterfile, the SNP information from the RGset is extracted and exported to the file `r gsub("/","/ ", paste0(outputdir,"/extracted-snps","_",projectname,"-",formatted.time,".csv"))`. 
This information can be used to detect mismatches in labeling of samples and often explains most of the sex mismatches.
Homozygotes should have values around $0$ and $1$, whereas heterozygotes have values close to $0.5$. 
Please consider this when comparing to the genotyping from other sources which may be coded $0$ - $1$ - $2$. 

```{r} 
if(exists("extractSNPs") && extractSNPs%in%"TRUE"){
    if(exists("snp.extraction")){
        write.csv(snp.extraction, file = paste0(outputdir,"/extracted-snps","_",projectname,"-",formatted.time,".csv"),row.names=T)
    } else {
        cat("\nAn error occurs during SNP extraction. No results are exported.\n")
    }
}

```


### Data preparation

The probes are divided by chromosome type: autosomal probes, chromosome X probes and chromosome Y probes.
For this step we need the annotationfile.

```{r, label = 'annotation'}
# works fine on EPICv2

anno=read.csv(annotationfile,as.is=TRUE, skip = 7) 

# problem: Name is not unique in merged annotationfile if we use MAPINFO which differs between arrays
# anno=anno[,c('Infinium_Design_Type','Color_Channel', 'CHR', 'MAPINFO', 'Name')]
# currently we only seem to use CHR and Name; because MAPINFO is different in EPIC v1 and v2, we dismiss this variable as long as we don't use it anyway

# also there are CHR values "","M","chr0" in the original file; those are dismissed in being not selected as neither autosome nor sexchromosome

anno=anno[,c('Infinium_Design_Type','Color_Channel', 'CHR', 'Name')]

 # align chromosome notation 
 anno$CHR <- gsub("chr","",as.character(anno$CHR))

 # this is a bit redundant since we align the chromosome notation
 chrX_descr <- grep('X', anno$CHR, value = T)[1]
 chrY_descr <- grep('Y', anno$CHR, value = T)[1]
 
 # get autosomal probes
 cas=anno[substr(anno$Name, 1,3)=='ch.' & (anno$CHR %in% c(as.character(1:22),"M")),] # M is mitochondrial
 cgs=anno[substr(anno$Name, 1,2)=='cg'& (anno$CHR %in% c(as.character(1:22),"M"))),]
 auto = c(cgs$Name, cas$Name)
 auto=as.matrix(auto)

 # get chrX probes 
 xcas=anno[substr(anno$Name, 1,3)=='ch.' & (anno$CHR %in% c(chrX_descr)),]
 xcgs=anno[substr(anno$Name, 1,2)=='cg'& (anno$CHR %in% c(chrX_descr)),]
 sexchrX = c(xcgs$Name, xcas$Name)
 sexchrX=as.matrix(sexchrX)

 # get chrY probes
 ycas=anno[substr(anno$Name, 1,3)=='ch.' & (anno$CHR %in% chrY_descr),]
 ycgs=anno[substr(anno$Name, 1,2)=='cg'& (anno$CHR %in% chrY_descr),]
 sexchrY = c(ycgs$Name, ycas$Name)
 sexchrY=as.matrix(sexchrY)

```

### High-level quality control


High level quality control includes detection p-value filter, restriction to the samples listed in the samplesfile and call rate filtering.

We calculate raw beta values for both autosomal and sex chromosome data.
In our further calculations beta value data always is processed separately for autosomes and gametes. 

* Detection p-values are illustrated in the following plots. Low p-values indicate that the signal is unlikely to be background noise. 

```{r, label='detection_p-values'} 
# works fine on EPICv2
dpvec <- dp.all
dim(dpvec) <- c(nrow(dp.all)*ncol(dp.all),1)

# plot detection P
dpvecplot <- dpvec
dpvecplot[which(dpvecplot==0)] <- 1E-20
if(sum(dpvec>0)>0){
	hist(-log10(dpvec[!dpvec%in%0]),breaks=30, main = "detection p-values: only positive values")
}
```



```{r, label='detection_p-values_zero'}
hist(-log10(dpvecplot),breaks=30, main = "detection p-values: zero values set to 1E-20")
rm(dpvecplot)
```
\pagebreak


The following table summarizes how many detection p-values are smaller than the threshold $`r detPthreshold `$ given in the *parameterfile*, or 0.01: 

 threshold           | count                                       | proportion
---------------------|---------------------------------------------|-----------------------------------------------------
$`r detPthreshold `$ | $`r length(which(dpvec<detPthreshold))`$    | $`r length(which(dpvec<detPthreshold))/length(dpvec)`$
0.01                 | $`r length(which(dpvec<0.01))`$             | $`r length(which(dpvec<0.01))/length(dpvec)`$

$`r sum(is.na(dpvec))`$ detection p-values are missing.

```{r}
#set detection p-value threshold
thres=detPthreshold
d=dp.all[rownames(TypeII.Green.All),colnames(TypeII.Green.All)]
TypeII.Green.All.d = ifelse(d<thres,TypeII.Green.All,NA)
TypeII.Red.All.d = ifelse(d<thres,TypeII.Red.All,NA)
d=dp.all[rownames(TypeI.Green.M.All),colnames(TypeI.Green.M.All)]
TypeI.Green.M.All.d = ifelse(d<thres,TypeI.Green.M.All,NA)
TypeI.Green.U.All.d = ifelse(d<thres,TypeI.Green.U.All,NA)
d=dp.all[rownames(TypeI.Red.M.All),colnames(TypeI.Red.M.All)]
TypeI.Red.M.All.d = ifelse(d<thres,TypeI.Red.M.All,NA)
TypeI.Red.U.All.d = ifelse(d<thres,TypeI.Red.U.All,NA)

rm(d)
rm(TypeII.Red.All, TypeII.Green.All, TypeI.Red.M.All, TypeI.Red.U.All, TypeI.Green.M.All, TypeI.Green.U.All) 

samples=colnames(TypeI.Red.M.All.d)
```

$`r length(which(dpvec>detPthreshold))`$   ($`r round(length(which(dpvec>detPthreshold))/length(dpvec), digits = 3)*100`$ \%)   measurements are excluded because their detection p-value is bigger than $`r detPthreshold`$. Only values with a detection p-value strictly smaller the threshold are kept.
To skip this filtering, set the parameter *detPthreshold* to a value **strictly** bigger than 1 in the *parameterfile.R*.


```{r}

#autosomes ------------------------------------------------------------------
 category=auto
 markers=as.matrix(intersect(rownames(TypeII.Green.All.d), category))
# head(markers)
TypeII.Green = TypeII.Green.All.d[markers,samples]
TypeII.Red = TypeII.Red.All.d[markers,samples]
markers=intersect(rownames(TypeI.Green.M.All.d), category)
TypeI.Green.M = TypeI.Green.M.All.d[markers,samples]
TypeI.Green.U = TypeI.Green.U.All.d[markers,samples]
markers=intersect(rownames(TypeI.Red.M.All.d), category)
TypeI.Red.M = TypeI.Red.M.All.d[markers,samples]
TypeI.Red.U = TypeI.Red.U.All.d[markers,samples]

#raw betas
TypeII.betas = TypeII.Green/(TypeII.Red+TypeII.Green+100)
TypeI.Green.betas = TypeI.Green.M/(TypeI.Green.M+TypeI.Green.U+100)
TypeI.Red.betas = TypeI.Red.M/(TypeI.Red.M+TypeI.Red.U+100)
beta.raw = as.matrix(rbind(TypeII.betas,TypeI.Green.betas,TypeI.Red.betas))

# sex chromosomes ------------------------------------------------------------------

category=c(sexchrX,sexchrY)
markers=as.matrix(intersect(rownames(TypeII.Green.All.d), category))
TypeII.Green = TypeII.Green.All.d[markers,samples]
TypeII.Red = TypeII.Red.All.d[markers,samples]
markers=intersect(rownames(TypeI.Green.M.All.d), category)
TypeI.Green.M = TypeI.Green.M.All.d[markers,samples]
TypeI.Green.U = TypeI.Green.U.All.d[markers,samples]
markers=intersect(rownames(TypeI.Red.M.All.d), category)
TypeI.Red.M = TypeI.Red.M.All.d[markers,samples]
TypeI.Red.U = TypeI.Red.U.All.d[markers,samples]

#raw betas
TypeII.betas = TypeII.Green/(TypeII.Red+TypeII.Green+100)
TypeI.Green.betas = TypeI.Green.M/(TypeI.Green.M+TypeI.Green.U+100)
TypeI.Red.betas = TypeI.Red.M/(TypeI.Red.M+TypeI.Red.U+100)
beta.raw.sex = as.matrix(rbind(TypeII.betas,TypeI.Green.betas,TypeI.Red.betas))
 
rm(TypeII.Red, TypeII.Green, TypeI.Red.M, TypeI.Red.U, TypeI.Green.M, TypeI.Green.U) 
 
```


```{r, label = 'samplecall.markercall'}
# calculate sample and marker calls without filter -- used for sample filter 
sample.call=colSums(!is.na(beta.raw))/nrow(beta.raw)
marker.call=rowSums(!is.na(beta.raw))/ncol(beta.raw)

# remove samples not in samplesfile
samplesinclude <- intersect(names(sample.call),datsamples$Sentrix_Code)
sample.call <- sample.call[samplesinclude]
ctrl.complete.Green.all <- ctrl.complete.Green.all[,samplesinclude]
ctrl.complete.Red.all <- ctrl.complete.Red.all[,samplesinclude]
beta.raw.sex <- beta.raw.sex[,samplesinclude]
beta.raw <- beta.raw[,samplesinclude]

# save.image("test_runbyhand.Rdata")
```

* Identified by the samplefile, $`r length(samplesinclude)`$ samples are included in the analysis.


beta values:   | autosomes           |  sex chromosomes 
---------------|---------------------|----------------------------
dimension:     | $`r dim(beta.raw)`$ | $`r dim(beta.raw.sex)`$

```{r, label='beta-densities'}
if(length(samplesinclude)<101){
	cat("\nThe sample names of the included samples:\n")
	datsamples$Sample_Name[datsamples$Sentrix_Code %in%samplesinclude]
}

plot.beta.densities = function(beta, title){
  if(!is.null(dim(beta))){
  	densities = apply(beta,2,function(x){ density(x, na.rm = TRUE) } )
  	xmax = max(sapply(densities, function(d){max(d$x)}))
  	xmin = min(sapply(densities, function(d){min(d$x)}))
  	ymax = max(sapply(densities, function(d){max(d$y)}))
  
  	plot(NA, xlim = c(xmin,xmax), ylim = c(0,ymax), main = title, ylab = "")
  	colors = rainbow(10)
  	for(i in 1:ncol(beta)){
  		lines(densities[[i]], col = colors[i%%10 + 1])
  	}
  } else if(length(beta) > 1){
    plot(density(beta, na.rm = TRUE), main = title)
  }
}
plot.beta.densities(beta.raw,"Densities of raw autosomal beta values per sample")
```



```{r}
# call-rate filtering

samples.filtered <- data.frame()
bufout <- names(sample.call[sample.call<=callrate.thres])
if (length(bufout)>0) samples.filtered <- data.frame(sample=bufout,x=NA,y=NA,filter=paste0("callrate ",callrate.thres),stringsAsFactors=F)
```
  
* There is call-rate filtering with threshold $`r callrate.thres`$.

* $`r length(bufout)`$ samples were tagged for exclusion because the call-rate was below the threshold $`r callrate.thres`$.


```{r, label = 'sample_call'}
# plot sample call rates
hist(sample.call,breaks=100, main = "sample call rates")
```

```{r, label = sample_call_zoomx}
# plot sample call rates
hist(sample.call,breaks=100, main = "sample call rates zoomed x-axis", xlim = c(0.85,1), sub = "zoomed x-axis is fixed to 0.85 to 1")
```

```{r, label = sample_call_zoomy}
# plot sample call rates
hist(sample.call,breaks=100, main = "sample call rates zoomed y-axis", ylim = c(0,30), sub = "zoomed y axis is fixed to 0 to 30")
```

$`r max(0,length(sample.call[which(sample.call<=0.98)]))`$ of all sample call rates are lower than 0.98,  
 and $`r length(sample.call[which(sample.call<=callrate.thres)])`$ are lower than the threshold $`r callrate.thres`$.


We have a look at the marker call rates as well:


```{r, label = marker_call}
hist(marker.call,breaks=100, main = "marker call rates")
```


```{r, label = marker_call_zoom}
hist(marker.call,breaks=100, main = "marker call rates zoomed y-axis", ylim = c(0,500), sub = "zoomed y axis is fixed to 0 to 500")
```  

$`r max(0,length(marker.call[which(marker.call<=0.98)]))`$ of all marker call rates are lower than 0.98,  
 and $`r length(marker.call[which(marker.call<=0.95)])`$ are lower than the threshold 0.95.


The results of the sample call rate filter are included in the export file **samples_filtered.csv** which also documents the following control-probe based quality control.


